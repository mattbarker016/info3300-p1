<html>
<head>
	<script src="https://d3js.org/d3.v5.min.js"></script>
	<script src="https://d3js.org/topojson.v2.min.js"></script>
</head>
<style>

/* path {
  stroke: #fff;
  stroke-width: .5;
  stroke-dasharray: 1;
  fill: #afafaf;
} */

.region {
	/* fill: red; */
	/* stroke: none; */
	stroke: black;
	stroke-width: 1px;
	fill: grey;
}


</style>

<body>

<h1 id="title">Project 1</h1>
<p id="header">Aileen Cai (ac952), Anne Bonalle (aeb295), Matt Barker (mjb485)</p>

<br>

<p>Data is taken from <a href="https://www1.nyc.gov/site/finance/taxes/property-rolling-sales-data.page">NYC.gov</a>. The data represents New York City Sales Data
from January 2018 to December 2018.</p>

<br>


<!-- testing -->

<svg id="manhattan" width="1500" height="2000" style="background: #F5F5F5"></svg>

<script>

let dataURL = "http://data.beta.nyc//dataset/0ff93d2d-90ba-457c-9f7e-39e47bf2ac5f/resource/35dd04fb-81b3-479b-a074-a27a37888ce7/download/d085e2f8d0b54d4590b1e7d1f35594c1pediacitiesnycneighborhoods.geojson"

	manhattanData = []
	neighborhoodMapping = {}

	d3.json(dataURL).then(function(features) {

		manhattanData = features["features"].filter(function (feature) {
			if (feature == null || feature == undefined) {
				return false;
			}
			return feature.properties.borough == "Manhattan";
		});

		var mData = manhattanData;

		var svg = d3.select("svg#manhattan"),
		width = +svg.attr("width"),
		height = +svg.attr("height");

		var path = d3.geoPath()
			.projection(d3.geoConicConformal()
			.parallels([33, 45])
			.rotate([96, -39])
			.fitSize([width, height], features));

		svg.selectAll("path")
			.data(mData)
			.enter()
			.append("path")
			.attr("class","region")
			.attr("d", path);

// });

	// Start of Data Parsing

	//
	// Variables & Constants
	//

	/**

	Schema

	{

		"neighborhood_name" : {

			// Average sale price of property sales
			avg_price: Number

			// Average sq. ft. size of property sales
			avg_sq_ft: Number

			// Number of property sales used to find average price
			price_count : Number (Int)

			// Number of property sales used to find sq. ft.
			sq_ft_count : Number (Int)

			// The total sum of all sales in filtered data
			tot_price : Number (Int)

			// The total sum of all square footage in filtered data
			tot_sq_ft : Number (Int)

		},

		...

	}
	*/
	var property_data = {};

	/**
	Each property sale has n multiple units. When true, data parsing will
	divide sq. ft. and cost among the number of units equally, creating
	n data points based off one initial data point. When false, each property
	sale will be treated as one data point.

	Reccomended: false
	*/
	var useEachUnitAsDataPoint = false;

	//
	// Helper Functions
	//

	function opt(d) {
		return isNaN(d) ? 0 : d
	}

	function getNumber(d) {
		var n = Number(d.replace(/[^0-9.-]+/g,""));
		return opt(parseInt(n, 10));
	}

	/**
		avg - Current existing average
		count - Current existing count of numbers in average
		val - New value to be added to average
		amt - The amount of data points that make up `val`. Default 1.
	*/
	function updateAverage(avg, count, val, amt=1) {
		return ((avg * count) + val) / (count + amt);
	}

	//
	// Main
	//

	d3.csv("data/manhattan_sales.csv", function(d) {
	  	return {
	    	neighborhood : d["NEIGHBORHOOD"],
	    	total_units : +d["TOTAL UNITS"],
	    	sq_ft : getNumber(d["LAND SQUARE FEET"]),
	    	price : getNumber(d["SALE PRICE"])
	  	};
	}).then(function(data) {

		data.filter(function (d) {

		});

		data.forEach( (property, i) => {
			if (property.neighborhood in property_data) {
				var entry = property_data[property.neighborhood];
				var sq_ft_val = entry.tot_sq_ft;
				var price_val = entry.tot_price;

				var price_count = entry.price_count;
				var sq_ft_count = entry.sq_ft_count;
				var new_amt = useEachUnitAsDataPoint ? property.total_units : 1;

				sq_ft_val += property.sq_ft;
				price_val += property.price;
				price_count += property.price > 0 ? new_amt : 0;
				sq_ft_count += property.sq_ft > 0 ? new_amt : 0;

				property_data[property.neighborhood] = {
					"tot_sq_ft" : sq_ft_val,
					"tot_price" : price_val,
					"price_count" : price_count,
					"sq_ft_count" : sq_ft_count
				};

			} else {

				var price_count = 0;
				var sq_ft_count = 0;
				var new_amt = useEachUnitAsDataPoint ? property.total_units : 1;

				price_count = property.price > 0 ? new_amt : 0;
				sq_ft_count = property.sq_ft > 0 ? new_amt : 0;

				property_data[property.neighborhood] = {
					"tot_sq_ft" : property.sq_ft,
					"tot_price" : property.price,
					"sq_ft_count" : sq_ft_count,
					"price_count" : price_count
				};

			}

		});

		// Calculate data
		var min_ratio = Number.MAX_SAFE_INTEGER;
		var max_ratio = 0;
		for (var key in property_data) {
			var value = property_data[key];
			var avg_sq_ft = value.tot_sq_ft / value.sq_ft_count;
			var avg_price = value.tot_price / value.price_count;
			property_data[key].avg_sq_ft = avg_sq_ft;
			property_data[key].avg_price = avg_price;
			property_data[key].ratio = avg_price / avg_sq_ft
			if (property_data[key].ratio < min_ratio) {
				min_ratio = property_data[key].ratio
			}
			if (property_data[key].ratio > max_ratio) {
				max_ratio = property_data[key].ratio
			}
		}



		//
		// End of Data Parsing
		//

		console.log('property_data', property_data);

		function upperFirstLetter(string) {
		    return string.charAt(0).toUpperCase() + string.slice(1);
		}
		function lowerCaseWords(string) {
		    return string.replace(/\w\S*/g, function (word) {
		        return word.charAt(0) + word.slice(1).toLowerCase();
		    });
		}

		const colorScale = d3.scaleQuantile()
                          	.domain([min_ratio, max_ratio])
                          	.range(["#fff","#f6fbfc","#adc2da","#8879b3","#762b80"]);

		svg.selectAll(".region")
			.style("fill", function(d) {
				var key = d.properties.neighborhood.toUpperCase();
				var num = (key in property_data) ? property_data[key].ratio : min_ratio;
				return colorScale(num);
			});


	});

});

</script>
